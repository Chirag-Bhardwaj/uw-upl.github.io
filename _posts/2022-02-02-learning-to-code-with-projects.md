---
layout: post
author: Rudy Banerjee
---

Computer science is a vast field, and there are tons of different ways that people can learn and get involved with it. One of the best ways to do so is by doing computer science projects. There are many different ways to go about doing so: tinkering around with tools and tutorials freely available on the internet, attempting a longer project of some kind involving dedicated research and looking into things, and working on group projects in different settings. All of these are great ways to complement classroom learning, provide interesting directions for career directions, and help with internships and future employment. However, people sometimes have difficulty finding projects and continuing with projects they have already started. This is a natural phenomenon, and there are ways to avoid this.

### Inspiration is out there online, seek out what interests you

One thing to note when looking for programming project ideas is that anyone can learn all the computer science that a 4-year degree can get you entirely from [online sources](https://github.com/ossu/computer-science) if they have a decent computer with access to the internet, some of these being [entirely on YouTube](https://laconicml.com/computer-science-curriculum-youtube-videos/), so you should keep in mind that you can do great things from the knowledge that accumulates on the internet. Additionally there is material [way beyond](https://github.com/floodsung/Deep-Learning-Papers-Reading-Roadmap) what you might learn in a traditional computer science classroom, with [people](https://www.youtube.com/c/YannicKilcher) willing to explain it to you, regardless of whether you are a [Machine learning](https://www.youtube.com/c/MachineLearningwithPhil) person, a [Computer Graphics](https://www.youtube.com/c/TheChernoProject) person, a [Systems](https://pages.cs.wisc.edu/~remzi/Classes/537/Fall2021/) person, a [Computer Engineer](https://www.youtube.com/c/BenEater), a [beginner](https://www.youtube.com/c/TheCodingTrain) who wants to [follow tutorials](https://www.youtube.com/c/sentdex), or someone else entirely. (This paragraph is about interesting resources I found online while looking for projects to get involved in)

From this selection of sources, you may already be able to identify my biases (not once have I mentioned web development or application development, which I haven't looked into in any great capacity), but this should at least demonstrate the extent of what's possible to learn online. It also illustrates an important point that everyone who programs has something they are interested in, or at least has a subject they hate the least out of all other programming subjects, which they are willing to dedicate the most time and effort towards without feeling like they are forcing themselves to work. I couldn't write a line of JavaScript with a gun to my head. That's fine. With all of the different options that are available for you to try programming with, it is sometimes difficult to find a project to get started with, so I would recommend with going with whatever you feel the most like doing. It doesn't matter if it is what might look good on a resume if it isn't something that you enjoy or something that you are willing to put time and effort into.

If you want to explore project ideas or you just want to improve your computer science skills, there is an overwhelming amount of educational material online for you to dig through. I am consistently amazed by the quality of computer science content that exists online, and I am sure that you will be too.

Paragraph - Many people say that it is difficult to get started with programming things from scratch once they have gone through a tutorials.

### Projects can be exploratory or serious
Paragraph: What are serious projects, and what are exploratory projects? How do they differ?

I believe that there are generally two types of projects: exploratory projects and serious projects. I think that the distinction between them is important to understand as a programmer. Exploratory projects usually are for tinkering and exploring new tools, languages, and environments, and don't have any cost of failure associated with them. These could be forays into new languages, testing out different tools, following tutorials online, or seeing a cool project and trying to replicate it for yourself. In an exploratory project, it doesn't matter if you fail to create a working project or fail to understand a concept, because it is just experimentation.

Serious projects, on the other hand, do have a cost for failure. They are usually resume-worthy projects that have a cost of failure for not completing them. These projects are generally centered around solving a problem, accomplishing a goal, or just completing a project, but could also be for gaining a level of familiarity with a library, language, or programming concept. The important point about serious projects is that they have a criteria for success, and not meeting them results in a failure. The criteria for success don't have to be too large, just getting the code for a minimum viable product to compile could be good enough for the situation. These projects also tend to include some measure of exploring and testing out new ideas and tools, which itself doesn't need to be stressful. However, these projects should have a clear distinction between success and failure to encourage you to dedicate continuous time and effort to the project and giving you the ability to learn from your mistakes.

Why is this distinction important?

It is important to have a good understanding of this distinction because picking a balance of these projects can really help your learning experience. Most computer science students have problems trying to stick to a single project, and end up jumping between projects without finishing them. Trying to attempt only serious projects may dampen your ability to enjoy the process of exploring different fields without feeling a sense of commitment and expectation weighing down on them. Conversely, if you are only dabbling in different fields without committing to a serious goal-oriented project, you may lose out on the chance to get real problem-solving experience that projects give you, like learning how to break a large project into manageable chunks, debug your code, and parse through message boards and documentation for help.

Having main projects to work on continuously but side projects for tinkering with is a good system for doing serious programming projects while also scratching the occasional itch to try new things out.

The tendency for programmers to want to jump between projects and explore shiny new opportunities is common, and I believe that doing so with temporary exploratory projects is a good idea. It allows you to have the fun of exploring new things and  getting too derailed from doing serious projects (if the stakes are sufficiently high enough and the project/team is interesting enough, then it makes working on the project more unavoidable).

It took me a while to be able to internalize this distinction of projects. Initially, I was going into different projects without a clear goal of what I wanted to do with the code or with the learning I would gain from it. I would attempt to do a few projects to try and scope out different areas of computer science, with the hope that I could put them on my resume, but after some time I would eventually find another shiny new project to work on and abandon my existing commitment due to compounding factors of decreasing motivation to work, decreasing interest in the goal, and various difficult roadblocks. However, the distinction allowed me to abandon almost all of the backlogged projects I had back then and start fresh with new projects that I could either commit to or not.

### It can be beneficial to have a few projects for tinkering without any responsibilities or commitment to a deadline or to a goal purely for learning

Suppose that you view projects not as individual, discrete things but as collections of asking and answering questions and as a process of learning skills and how to use certain tools. Maybe part of the allure of projects isn't that there is so much out there for you to do but so much for you to _learn_. If you want to create a fully working package of functionality like a game or an application, then maybe actually completing and finishing projects would be beneficial for you. However, it isn't necessary if your view is not to complete a project but to learn how to use a language or a set of tools. Just foraying into a field, following random tutorials, and experimenting with different tools and environments be meaningful on it's own, even if you have a project in mind and don't end up completing it.

Since I graduated high school, I have done a number of solo projects and some group projects. These solo projects have been forays into different programming languages and topics, some of them being [computer vision with Python](https://www.youtube.com/c/MurtazasWorkshopRoboticsandAI), [reinforcement learning in Python](https://www.youtube.com/playlist?list=PL-9x0_FO_lgn8hXJk5uRv1bO36xyTx00f), [socket programming in C](https://www.youtube.com/playlist?list=PLEAKPxTLOpJw-_omv62j2bpFC9NjA2T_e), [graphical applications with Rust for Linux](https://dev.to/davidedelpapa/rust-gui-introduction-a-k-a-the-state-of-rust-gui-libraries-as-of-january-2021-40gl#fltk), and tinkering with different Linux distributions. When starting these projects, I let go of any intention of creating a finished project. I pursued these purely because I thought they were interesting and I also thought they might be useful to explore for finding serious projects to implement in the future. I ended up going pretty far with the computer vision and reinforcement learning projects because I felt compelled to look into them and I found great resources on that material. I didn't end up doing much with the socket programming, Rust, and Linux development projects because they had a steep learning curve and required time and effort that I didn't want to spend on it.

Overall, just attempting these projects and putting at least a few hours into them benefited me in ways that I didn't expect. I learned how to set up different programming environments, as well as how to google well and identify useful information online. I learned a lot from those experiences, and I ended up putting some of them on my resume because I believed I had put enough effort into them to warrant it.

### Sometimes it is hard to maintain serious projects due to compounding factors

There are a lot of projects I started as serious long-term projects that I ended up scrapping without learning much from them. I wanted to create Unity games, because I wanted to create games I myself would play after I got bored of all the games I used to play, and I had a detailed vision for how the games were supposed to turn out. However, I tried to build 3 different games and I ended up abandoning all of them. This was very disappointing to me for several reasons. I had difficulty getting used to Unity environment, even though I had done these projects over the span of almost 2 years and spent lots of time trying to understand the environment. All 3 of them had tutorials on YouTube that were easy to follow and that laid out detailed instructions for how to use Unity. Even with all of the vast amount of resources online for Unity development, I ended up losing the motivation to  continue with these projects and just stopped working on them. This was especially disappointing for me because I was extremely excited about exploring this field of programming, but eventually I stopped working on the projects because of reasons I couldn't fully understand.

[This blog post](https://outline.com/9GJBGj) describes the journey of learning to code from a more pessimistic view, but I think it's generally correct. Unfortunately, programming is more than just following tutorials, and that fact hit me like a freight train. Many of the tutorials online include large amounts of hand-holding which will did not help me because I didn't try to understand the concepts beneath them, and adding custom code to my projects was significantly harder than I was expecting. After some time, I found myself in a limbo state where the tutorials I were following were not personalized to satisfy my needs and didn't fit my goals for the projects. More advanced resources became harder to find and harder to understand. At times trying to navigate a maze of complex topics and seemingly indecipherable documentation felt like a daunting task. Motivation to complete any particular project waxes and wanes, and multiple compounding factors like bugs, frustration at roadblocks and hard-to-understand concepts, a lack of progress and loss of motivation can lead to people axing a project, even if it is a project they started enthusiastically looking to build something they were passionate about.

### To do well in serious projects, have a smart approach, expect difficulty, and put some skin in the game

It took me a while to find a serious project initially, and I didn't have long-term project for most of my freshman year. However, I did take part in some interesting experiences and they changed my perception of myself and what I was capable of. What helped me significantly was having high stakes, clear goals and deadlines, working with mentors and in a group. By taking part in these projects, I had locked myself into commitments with other people and specific deadlines that I couldn't easily get out of.

I had participated in a 48-hour hackathon and I built a working website with AWS Beanstalk and Django with zero web development experience. Those 48 hours were an extreme flurry of frantic activity and I don't remember how I built the website or what resources I used, but by the end of the 48 hours, I had a working minimum viable product that I was able to showcase at the end of the hackathon. I didn't win any awards or get any honorable mentions because I had done the project solo and my project was extremely bare-bones. However, just attempting it and creating a working demo was a success for me, because I had learned some of the basics of web development on the spot and I gained a lot of project development experience. The intense deadline of the hackathon forced me to consider time-efficient options at every step of the engineering process. I needed to come up with a general software architecture for the project and break it down into individual pieces that I could learn how to build on my own. In this case, I had to consider the ways that AWS and Django interacted together. I was also forced to make the most of the materials I could find online for setting up the website and integrating it with AWS Beanstalk. This project helped me learn the basics of tackling large programming projects, solving problems using the internet, and helped me gain confidence for doing more complex projects in the future.

I also completed an [11-week-long Coursera course](https://www.coursera.org/learn/machine-learning) in 4 weeks with two of my friends. This isn't really a project in the typical sense, but it was an intense endeavor that I believed was useful for demonstrating the possibilities of self-learning and the benefits of working in group projects. Working with a group was helpful because we discussed our problems and shared our frustrations during the hardest parts. I am fairly certain I would have axed the project within the second week if I was doing this alone, and this experience really showed me how working in a team could help me accomplish something beyond my current capabilities.

I have also completed a research project for class credit under a professor here for creating a program extracting a floorplan from a 3D mesh rendering a from by a HoloLens in real-time. Since I worked with a graduate student as a mentor to the project, this experience gave me a great understanding of how to use mentors as a resource. Even though taking part in a research project has barriers to entry of it's own, I was amazed by how much it was like any other project. I was left almost entirely on my own and given project specifications that I had to build my project around. This initially made me pretty nervous but after some time, I started to realize that the level of difficulty for the project wasn't significantly harder than a CS 400 or 540 (AI) project. The hardest part of the project was reading the documentation for figuring out how to use different libraries and consistently keeping up with the project during the course of the semester. My mentor wasn't familiar with the tools that I was using but was still able to help me with my approach when I needed, and it made me realize that almost anyone with programming experience can act as a mentor to anyone else.

### Projects are hard but rewarding

Computer science is hard, but pursuing projects with others makes it incredibly rewarding. Part of the benefit of projects is the experience of participating in them and even if you experience failures with programming or quit your projects, just know that talking to others about this can be incredibly rewarding. I have spoken to many different types of computer science students from inexperienced freshman to experienced seniors, and while many of them have expressed frustration with their classes, most of them have mentioned their appreciation for the ways that projects help them learn and great projects can help them grow.

### Interesting resources

I have listed many different resources in this post, but feel free to look around the internet for more or ask us for more if you have questions about anything.

If you want to create a good project to build your resume or if you want to dive deep into a subject, then dedicating significant time and effort to reaching a goal and completing a project will be necessary. [This blog post](https://medium.com/@aschmelyun/how-i-went-from-abandoning-projects-to-actually-getting-stuff-done-41f02a64faa1) describes an approach someone took to help them focus on a project they were working on amidst tons of distracting thoughts and cool ideas.

[This blog post](https://www.freecodecamp.org/news/how-to-go-from-coding-tutorials-to-building-your-own-projects-b9ab51074980/) poses a direction for starting from scratch. While it is specifically featuring front-end development, it's advice seems pretty fundamental: freely build upon small applications or programs that you have already built, create your own small projects from scratch, and show your work off to others.

### Interesting notes

Remzi's OS class website is not only listed above (alongside his personal website containing information/material from all the classes he has taught including Grad-level OS and Grad-level distributed systems), his website is listed in the Open Source Society University link above as the recommended resource on learning about operating systems, which I think is pretty neat.

Also, the hackathon I took part in was definitely one of the most exciting programming experiences I have had in the past two years, and I would definitely recommend anyone who hasn't participated in a hackathon to do so (we have one coming up soon so look out for that).

